# В неориентированный взвешенный граф добавляют ребра. 
# Напишите программу, которая, после добавления ребер, находит сумму весов ребер в компоненте связности.

# На вход подаются два числа n и m - количество вершин в графе и количество производимых добавлений и запросов. 
# Далее следует список add из m строк. Каждая строка состоит из трех чисел x, y, w. 
# Это означает, что в граф добавляется ребро из вершины x в вершину y веса w. 
# Кратные ребра допустимы. И число A - вершина, для компоненты связности которой необходимо найти суммарный вес ребер.


# тут юзаем систему непересекающихся множеств
# суть в чем, у нас изначально n множеств по одному елементу, т.к ребер нет.
# Добавляя ребро мы чекаем у каждого елемента "представителя" его множества,
# если представители идентичны, значит очевидно элементы уже в одном множестве, мы нихуя не делаем
# там дальше крч все боле менее понятно с добавлением
class DSU:
    def __init__(self, n):
        self.parent = list(range(n))  # Инициализация - каждый элемент начинает как своя собственная "компонента связности"
        self.rank = [0] * n  # Инициализация рангов для оптимизации объединения

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # Рекурсивно находим корень компоненты для элемента x
        return self.parent[x]

    def union(self, x, y):
        root_x = self.find(x)  # Находим корень компоненты для x
        root_y = self.find(y)  # Находим корень компоненты для y
        if root_x != root_y:  # Если корни разные, значит компоненты разные
            if self.rank[root_x] < self.rank[root_y]:
                self.parent[root_x] = root_y  # Если ранг root_x меньше, делаем root_y родителем root_x
            elif self.rank[root_x] > self.rank[root_y]:
                self.parent[root_y] = root_x  # Иначе, делаем root_x родителем root_y
            else:
                self.parent[root_y] = root_x  # Если ранги равны, выбираем любой корень и делаем его родителем другого
                self.rank[root_x] += 1  # Увеличиваем ранг нового корня, так как он на один больше, чем был

def find_component_weight(n, m, add, A):
    dsu = DSU(n+1)  # Создаем СНМ для n вершин (индексация с 1)
    
    for x, y, w in add:
        dsu.union(x, y)  # Объединяем компоненты связности при добавлении ребра

    component_weight = [0] * (n+1)  # Создаем список для хранения весов компонент связности
    for x, y, w in add:
        component = dsu.find(x)  # Находим корень компоненты связности
        component_weight[component] += w  # Увеличиваем суммарный вес ребер компоненты
    return component_weight[dsu.find(A)]  # Возвращаем сумму весов ребер заданной компоненты связности

n = 5  # Количество вершин
m = 4  # Количество добавлений ребер
add = [(1, 2, 10), (2, 3, 20), (4, 5, 30), (1, 3, 15)]  # Список добавлений ребер
A = 1  # Вершина для которой нужно найти суммарный вес ребер

result = find_component_weight(n, m, add, A)
print(result)  # Выводим результат